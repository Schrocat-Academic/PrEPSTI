@author: David Stiasny
@date: 05/08/2020
@contact: dstiasny@outlook.com
@GitHub: dStass


* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Index
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

- Section 1: MDLL ............................................................. line   25
- Section 2: Concurrency ...................................................... line  100
  - Section 2a: package ....................................................... line  100
  - Section 2b: multithreading location ....................................... line  100
- Section 3: Simulation Reboot (at a given cycle) ............................. line  150
- Section 4: Build: Ant, Maven and dependencies ............................... line  200
- Section 5: JFreeChart: Shaded and Interval Plots ............................ line  250
- Section 6: Configuration files .............................................. line  300
- Section 7: Other miscellaneous topics ....................................... line  320
  - Section 7a: StringBuilder and StringBuffer ................................ line  350
  - Section 7b: Runtime analysis .............................................. line  370


* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Section 1: MDLL
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

- MDLL (Mapped Doubly-Linked List) is a data structure that combines two sub data 
  tructures (map and a doubly-linked list)

Supported operations:

Instantiation:
- [new] Supports instantiation without parameters the same way an ArrayList
  or HashMap is instantiated, i.e:
  - Constant-time operation
  - MDLL<Agent> agentMDLL = new MDLL<Agent>();

Adding:
- [add(..)] Supports adding objects by using a key and value. For this particular
  application, the key must be an integer,
  and keys are assumed to be unique, i.e. given (an Agent object) agent:
  - Constant-time operation
  - agentMDLL.add(agent.getAgentId(), agent)

- [addBefore(..)] Supports adding objects before another object given its key, i.e.:
  - Constant-time operation
  - agentMDLL.addBefore(agent.getAgentId(), agent, 2)
  - // this will add the new agent directly in position before the agent with id 2

- Assumptions:
  - key is of type integer
  - key is not equal to MDLL.HEAD_ID and MDLL.LAST_ID, reserved as -1 and -2
  - if these ids are required, make modifications to reserved ids accordingly

Checking:
- [contains(..)] Supports checking whether a key exists, i.e.:
  - Constant-time operation
  - boolean doesExist = agentMDLL.contains(2020)

Getting:
- [get(id)] Supports getting declared type objects given an existing key, i.e.:
  - Agent extractedAgent = agentMDLL.get(2020)
  - Constant-time operation

- [size()] Supports getting size of MDLL collection, i.e.:
  - Constant-time operation
  - int agentMDLLSize = agentMDLL.size()
  - // simply returns the number of exists nodes minus 2 reserved ndoes

Removing:
- [remove(id)] Supports removal of declared type objects given an existing key, i.e.:
  - Constant-time operation
  - removes an object from internal map and reassigns the correct pointers from
    internal doubly-linked list
  - returns a boolean on whether the removal was successful

Collection operations:
- [clone()] Supports returning a shallow copy of the collection,
  - Linear-time operation 

  What gets cloned:
  - MDLL collection
  - MDLLNodes

  What doesn't get cloned:
  - declared type objects

  Example, assuming we have two Agent objects (agent1 and agent2), and an MDLL
  containing them (originalMDLL)
  - MDLL<Agent> clonedMDLL = originalMDLL.clone()
  - // originalMDLL.size() == clonedMDLL.size()
  - originalMDLL.remove(0)
  - // originalMDLL.size() == 1, clonedMDLL.size() == 2
  - // if agent0 is modified, this Agent specific modification will also be modified
    in clonedMDLL

- [toArrayList()] Supports returning a conversion to ArrayList of objects, i.e.:
  - Linear-time operation
  - ArrayList<Agent> agentArrayList = agentMDLL.toArrayList()

- [returnShuffled()] Supports returning a new randomly shuffled MDLL, i.e.:
  - Linear-time operation
  - MDLL<Agent> shuffledMDLL = agentMDLL.returnShuffled()
  - this is accomplished by first randomly selecting an object and then applying
    addBefore(..) to it

- [getStream()] Supports returning a stream of declared type objects, i.e.:
  - Linear-time operation
  - Stream<Agent> agentStream = agentMDLL.getStream()
  - handles removal of reserved nodes (such as internal head and last nodes)

Traversing collection:
- Supports forward and backward moving iterators by calling agentMDLL.getForwardIterator()
- and agentMDLL.getBackwardIterator() respectively
- These implements the MDLLIterator interface, which inself extends the Iterator interface

Supported operations:
- [hasNext()] Supports checking whether the iterator can traverse forward by one
  - Constant-time operation
  - returns a boolean

- [next()] Supports iterating forward by one in the desired direction
  - Constant-time operation
  - returns type object
  - Agent nextObject = agentMDLLForwardIterator.next()
  - // internally agentMDLLForwardIterator also moves its internal pointer forward

- [iterateBack()] Supports iterating back by one and returning the desired object
  - Assumes user knows that iterating back is possible
  - this should only be used prior to removing an object the iterator is pointing to

- Traversal by utilising for each syntax, i.e.:
  - for (Agent agent : agentsMDLL) {
  -   ...
  - }

  Assumptions:
  - Currently does not support checking whether iterateBack() is a valid operation


Where it is used in this project:
  - maintaining a collection of current agents in the simmulation inside Community
    (replaces ArrayList<Agent>)
  - used in generateRelationships() for significance speed gain

Note: This uses significantly more memory than using a standard list


* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Section 2: Concurrency
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Section 2a: package PRSP.PrEPSTI.concurrency;
- contains two static methods to convert:
  - nested HashMap<K, HashMap<..>> to ConcurrentHashMap<K, ConcurrentHashMap<..>>
  - nested ConcurrentHashMap<K, ConcurrentHashMap<..>> to HashMap<K, HashMap<..>> 

- Primarily used when converting a HashMap to ConcurrentHashMap before multithreading
  and then converting back afterwards


Section 2b: Where multithreading is used in this application
- Community.runEcnounters(): retrieve a stream of agents from MDLL using getStream()
  and apply Agent.encounter() on each agent
- PopulationReporter.prepareCensusPropertyReport(): parallelised on agents per birth
  record
- ScreeningReporter.prepareYearsAtRiskIncidenceReport(): parallelised on backYears,
  generating each year's report in parallel
- ScreeningReporter.prepareRawAgentSiteReport(): parallelised on each agent when
looking at their infections

Note: currently does not support nested maps with other data structures, such as:
HashMap<K1, HashMap<K2, ArrayList<T>>>

Some things to note when parallelising and writing to HashMaps, they must first be
converted into ConcurrentHashMaps or the application is at risk of stalling
due to concurrency isues.
This can be done using the methods outlined in section 2a.


* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Section 3: Simulation Reboot (at a given cycle)
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

The application allows the user to restart a simulation at a particular cycle as
an extension to the previous functionality.
Given a particular reboot cycle, variable in config file: "REBOOT_FROM_CYCLE"

Note: REBOOT_FROM_CYCLE must be between 0 and the total length of the sim being rebooted
Note: if the user wants to reboot from the end of a given simulation,
      they can declare this value as the legnth of the simulation they want to reboot,
      or the alternatively, set this as '-1'

For this, two new -METADATA and -REBOOT files at that particular cycle are generated
and used for rebooting.
They take the form [TODO].

Part A: -REBOOT

In order to generate the -REBOOT file, Agent and Relationship reboot information are
generated.

1. Agent reboot:
- generated from PopulationReporter.generateCensusReport() with parameters:
  - cycle // to generate up to
  - new screeningReporter object

- Generates a rawReport containing all relevant information
Generates the following reports and combines them in the rawReport:
  - Agent testing report
  - Agent treated report
  - Census property report
  - Birth report of agents
  - Death report of agents
  - Agent site report
  - change report

This is done by preparing how the population looks at the start of the simulation;
followed by preparing the necessary change reports to different values throughout the
simulation,
followed by removing dead agents (stored in the death report).

Some introduced methods:
- prepareRawAgentSiteReport (runs concurrently)
  - extracts the correct infection string for each agent at each site to be added
    to -REBOOT file
- extractInfectionAndIncubationFromBackCycles
  - Calculates infectionTime and incubationTime by traversing backwards from the last
    cycle
  - until when the agent last had the infection
  - Once this cycle has been found, the infectionTime and incubationTime can be
    deduce with 
  - calculations representative in
    ScreeningReporter.extractInfectionAndIncubationFromBackCycles()

2. Relationship reboot:
- loop back over records, introduce relationships that have been created and
  remove those that have ended

Note: Agent ages can be off by 1 using this method due to the way their ages are
saved which will round to the nearest year

Part B: -METADATA

Duplicates the -METADATA file with modified MAX_CYCLES using the method:
- Reporter.DUPLICATE_METADATA_WITH_MODIFIED_PROPERTIES


* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Section 4: Build files with Ant and project migration to Maven post working from
home due to Covid-19
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Notable changes:

Packages are sourced in two ways:
1. Maven is used as an option using an IDE such as Eclipse and Visual Studio Code.
   Dependencies are sourced online, automatically downloaded and updated.
- maven-build.xml contains build information, the file used in this project
  is generated directly using Eclipse
- Dependencies and external packages can be added to the file pom.xml under
  the tag <dependencies>

2. Directly sourced and stored locally in the lib/ folder as .jar files
In order to add new dependencies, modify build.xml:
  a. Add the stored locations of each dependency under the comment given a library name
  <!-- declare locations of dependencies  -->
  b. Add the new library name in the <attribute name="Class-Path"> by modifying
  the value, directly under <!-- add all our dependencies in jar file -->

In order to build a project using Ant
Run: ant clean build clean
- this generates a .jar file in the build folder
- clean: used to remove compiled class files in target/

This is useful for running the simulation in environments where Maven is not available,
such as on a supercomputer. It is assumed Ant is available.

To modify build source, modify mainClass field in build.properties.
This changes which file in which the main method exists. 


* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Section 5: JFreeChart: Shaded and Interval Plots 
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *



* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Section 6: Configuration files
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Class introduced: ConfigLoader

This class is with static methods is used to load a specific .json configuration file
as described in the config.properties file

Calling ConfigLoader.load() will do three things:
1. Reads config.properties and extracts a path and file for the correct configuration
   file to be read.

2. Read the specified .json file from step 1 using the package simple-json

3. Sets the required information into the variables specified into variables in different
   classes.


Layout:

A typical config.json file should have the following variables pointing to dictionaries:
- paths
- community
- agent
- reporter
- presenter
- config_loader

Each of these fields represent a class, with the exception of 'paths'.

Within each dictionary, there will be a collection of key-value pairs.
If the key is NOT named "methods", then it is assumed the key is a variable
of the class it appears under.
Otherwise, for each key-value pairs under "methods", the key represents the name of
a methodunder that class.
Within each of these, there is a collection of key-value pairs that represent variables
that can be extracted by the getMethodVariable{Type} methods.

Pick the appropriate {Type} for the correct type to be extracted,
such as String or Boolean. A sample subsection of config.json:
- {
-   agent : {
-     "FILE_PATH" : "somePath",
-     "methods" : {
-       "interveneCommunity" : {
-         "startCycle" = "1"
-       }
-     }
-   }
- }

ConfigLoader.load() will set Agent.FILE_PATH to "somePath" and
when interveneCommunity() is called, the user can extract startCycle by calling the
appropropriate getMethodVariable{Type} method such as:
- int startCycle = ConfigLoader.getMethodVariableInteger("community",
-                                                        "interveneCommunity",
-                                                        "startCycle");

Note: Currently there is no separation between overloaded methods of the same name with
different argument types. A workaround is to name the methods slightly different with
arguments and call them accordingly. An example would be:
- getMethodVariableInteger("community", "interveneCommunity(int, float)", "startCycle")

Note: Saving static variable directly to classes is accomplished by hard-coded methods:
- loadPaths(),
- loadCommunity(),
- etc. 

For new variables, the user will have to modify these methods slightly to take those
into account.

Note: It has not been taken into account in the scenario where "methods" : { ... }
is empty within the curly brackets,if no method variables are required,
omit "methods" entirely from the .json configuration files.


* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Section 7: Other miscellaneous fixes and additions
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Section 7a: StringBuilder and StringBuffer

Many places in the code-base utilises StringBuilder and StringBuffer with the former
being the preferred choice. This effectively replaces concatenating strings or using
the += operator for string operations. This was implemented to reduce time taken to 
concatenate long strings many times over and over, as it brings the total time
taken to concatenate from linear time to constant time, using the .append() method.

The differences between both:
- StringBuilder: Faster when single-threading but not thread-safe
  - use when SINGLE-THREADING
- StringBuffer: Slower but can be used to append strings concurrently
  - use when MULTI-THREADING

A final .toString() statement is applied to convert a StringBuilder/StringBuffer object 
into a String


Section 7b: Runtime analysis

There is code in the background that measures how long methods take to run by the use
of the method:
- Community.RECORD_METHOD_TIME(String name, float time)

How the user can use this is by first measuring the system time when a method first starts
and then again at the end of the method, saving them into t0 and t1 variables respectively.
The user can then call the method:
- Community.RECORD_METHOD_TIME("methodName", t1 - t0);

This will record the time difference every time the method is called and saved under
the name "methodName".

No initialisation on the user's part is necessary as RECORD_METHOD_TIME handles this.

Note: At the current time, this method does not distinguish where RECORD_METHOD_TIME is
called from and solely relies on "methodName" to identify where the time difference is to
be saved. Consequently, if the user is measuring the time difference between two methods
of the same name in different classes and only declares the method name, this will lead to
the time differences combined together under the one name.

Good practice when calling RECORD_METHOD_TIME is to specify exactly the class names for
methodName, such as:
- Community.RECORD_METHOD_TIME("classA.methodName(param1), t1-t0)
- Community.RECORD_METHOD_TIME("classA.classB.methodName(param1, param2), t1-t0)
- etc.

Everything is then stored in Community.methodTimeStamp (which itself is a hashmap).

The user is able to then print the desired time records at the end of the application,
such as the following script sample:
- System.out.println("\n\nTime taken for each methods:");
- RECORD_METHOD_TIME("TOTAL", System.nanoTime() - timeInitial);
- HashMap<String, Float> methodPercentages = FINALISE_METHOD_TIME();
- ArrayList<String> keys = new ArrayList<String>(Community.methodsTimeStamp.keySet());
- Collections.sort(keys);
- for (String s : keys) {
-     System.out.println("- " + methodPercentages.get(s) * 100 + "% : " + s + " -> "
-                             + Community.methodsTimeStamp.get(s) / 1_000_000_000 + "s");
- }
- System.out.println("Completed");

Note: FINALISE_METHOD_TIME() will add a total time taken for all recorded methods, this is
not to be mistaken for the entire duration of the simulation unless the user records the
time taken for all methods without any double counting. It will also populate the hashmap
methodPercentages, with the proper % of time taken by dividing each individual time over
the total calculated.

Note: Care must be taken as double counting is possible, an example being if the user
measures the time taken for method A and B to run, where method B is called by method A.
This will effectively add the duration of method B into method A.
Currently the implementation does not handle any double counting fix.




